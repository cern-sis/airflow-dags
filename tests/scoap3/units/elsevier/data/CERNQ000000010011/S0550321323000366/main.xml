<?xml version="1.0" encoding="utf-8"?><!DOCTYPE article PUBLIC "-//ES//DTD journal article DTD version 5.6.0//EN//XML" "art560.dtd" [<!ENTITY gr001 SYSTEM "gr001" NDATA IMAGE><!ENTITY gr002 SYSTEM "gr002" NDATA IMAGE><!ENTITY gr003 SYSTEM "gr003" NDATA IMAGE><!ENTITY gr004 SYSTEM "gr004" NDATA IMAGE><!ENTITY gr005 SYSTEM "gr005" NDATA IMAGE><!ENTITY gr006 SYSTEM "gr006" NDATA IMAGE><!ENTITY gr007 SYSTEM "gr007" NDATA IMAGE>]><article xmlns="http://www.elsevier.com/xml/ja/dtd" xmlns:ce="http://www.elsevier.com/xml/common/dtd" xmlns:sa="http://www.elsevier.com/xml/common/struct-aff/dtd" xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/dtd" xmlns:xlink="http://www.w3.org/1999/xlink" docsubtype="fla" xml:lang="en"><item-info><jid>NUPHB</jid><aid>116107</aid><ce:article-number>116107</ce:article-number><ce:pii>S0550-3213(23)00036-6</ce:pii><ce:doi>10.1016/j.nuclphysb.2023.116107</ce:doi><ce:copyright year="2023" type="other">The Author(s)</ce:copyright><ce:doctopics><ce:doctopic id="doc0010"><ce:text>Quantum Field Theory and Statistical Systems</ce:text></ce:doctopic></ce:doctopics></item-info><ce:floats><ce:figure id="fg0010"><ce:label>Fig. 1</ce:label><ce:caption id="cp0010"><ce:simple-para id="sp0010">Blocking procedure to reduce a two-dimensional 4 × 4 lattice to a single tensor using alternating contractions in the horizontal and vertical directions.</ce:simple-para></ce:caption><ce:alt-text role="short" id="at0010">Fig. 1</ce:alt-text><ce:link locator="gr001" xlink:type="simple" xlink:href="pii:S0550321323000366/gr001" xlink:role="http://data.elsevier.com/vocabulary/ElsevierContentTypes/23.4" id="ln0010"/></ce:figure><ce:figure id="fg0020"><ce:label>Fig. 2</ce:label><ce:caption id="cp0020"><ce:simple-para id="sp0020">Illustration of the contraction <ce:italic>T</ce:italic>⋆<ce:inf>1</ce:inf><ce:italic>T</ce:italic> = <ce:italic>M</ce:italic> along the 1-direction in a three-dimensional system, as in <ce:cross-ref refid="fm0020" id="crf0010">(2)</ce:cross-ref>. The square nodes represent the fusion of the original tensor indices into the combined fat indices <ce:cross-ref refid="fm0030" id="crf0020">(3)</ce:cross-ref> of <ce:italic>M</ce:italic>.</ce:simple-para></ce:caption><ce:alt-text role="short" id="at0020">Fig. 2</ce:alt-text><ce:link locator="gr002" xlink:type="simple" xlink:href="pii:S0550321323000366/gr002" xlink:role="http://data.elsevier.com/vocabulary/ElsevierContentTypes/23.4" id="ln0020"/></ce:figure><ce:figure id="fg0030"><ce:label>Fig. 3</ce:label><ce:caption id="cp0030"><ce:simple-para id="sp0030">Two tensors <ce:italic>T</ce:italic> are contracted over their shared vertical link, producing a tensor <ce:italic>M</ce:italic> with fat horizontal modes (green box). The fat modes of <ce:italic>M</ce:italic> are projected onto subspaces with the projectors <ce:italic>P</ce:italic><ce:inf><ce:italic>U</ce:italic></ce:inf> = <ce:italic>UU</ce:italic><ce:sup><ce:italic>T</ce:italic></ce:sup> and <ce:italic>P</ce:italic><ce:inf><ce:italic>V</ce:italic></ce:inf> = <ce:italic>VV</ce:italic><ce:sup><ce:italic>T</ce:italic></ce:sup>, respectively, to form the lower rank approximation <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> of <ce:cross-ref refid="fm0200" id="crf0030">(20)</ce:cross-ref> (blue box). As part of the construction one recognizes the core tensor <ce:italic>S</ce:italic> of <ce:cross-ref refid="fm0190" id="crf0040">(19)</ce:cross-ref> (red box). Note that the matrices <ce:italic>U</ce:italic>, <ce:italic>U</ce:italic><ce:sup><ce:italic>T</ce:italic></ce:sup>, <ce:italic>V</ce:italic> and <ce:italic>V</ce:italic><ce:sup><ce:italic>T</ce:italic></ce:sup>, described by diamonds in the figure, are applied from the inside to the outside, in correspondence with <ce:cross-ref refid="fm0190" id="crf0050">(19)</ce:cross-ref> and <ce:cross-ref refid="fm0200" id="crf0060">(20)</ce:cross-ref>.</ce:simple-para></ce:caption><ce:alt-text role="short" id="at0030">Fig. 3</ce:alt-text><ce:link locator="gr003" xlink:type="simple" xlink:href="pii:S0550321323000366/gr003" xlink:role="http://data.elsevier.com/vocabulary/ElsevierContentTypes/23.4" id="ln0030"/></ce:figure><ce:figure id="fg0040"><ce:label>Fig. 4</ce:label><ce:caption id="cp0040"><ce:simple-para id="sp0040">Two approximations <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math>, constructed in <ce:cross-ref refid="fg0030" id="crf0070">Fig. 3</ce:cross-ref>, are contracted in the horizontal direction. This illustrates how the projections performed in the first contraction are concatenated when making this second contraction, leading to a product <ce:italic>P</ce:italic><ce:inf><ce:italic>U</ce:italic></ce:inf><ce:italic>P</ce:italic><ce:inf><ce:italic>V</ce:italic></ce:inf>. Here a new building block <ce:italic>G</ce:italic> = <ce:italic>U</ce:italic><ce:sup><ce:italic>T</ce:italic></ce:sup><ce:italic>V</ce:italic> arises, which we call a <ce:italic>merger</ce:italic> between two core tensors <ce:italic>S</ce:italic>. Note that, for consistency, the matrices operate in chronological order (from the inside to the outside with respect to <ce:italic>M</ce:italic> of <ce:cross-ref refid="fg0030" id="crf0080">Fig. 3</ce:cross-ref>) and not from left to right. The half-mergers on the left and right will connect to their counter parts in further contractions.</ce:simple-para></ce:caption><ce:alt-text role="short" id="at0040">Fig. 4</ce:alt-text><ce:link locator="gr004" xlink:type="simple" xlink:href="pii:S0550321323000366/gr004" xlink:role="http://data.elsevier.com/vocabulary/ElsevierContentTypes/23.4" id="ln0040"/></ce:figure><ce:figure id="fg0050"><ce:label>Fig. 5</ce:label><ce:caption id="cp0050"><ce:simple-para id="sp0050">The construction in <ce:cross-ref refid="fg0040" id="crf0090">Fig. 4</ce:cross-ref> drastically simplifies when choosing <ce:italic>U</ce:italic> = <ce:italic>V</ce:italic>, as the merger <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si83.svg"><mml:mi>G</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="double-struck">1</mml:mn></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:math> in this case. The frames are solely needed to construct the core tensor <ce:italic>S</ce:italic>. This property will spread through the entire blocking procedure (including the final trace), such that the calculation can be performed using the core tensor only.</ce:simple-para></ce:caption><ce:alt-text role="short" id="at0050">Fig. 5</ce:alt-text><ce:link locator="gr005" xlink:type="simple" xlink:href="pii:S0550321323000366/gr005" xlink:role="http://data.elsevier.com/vocabulary/ElsevierContentTypes/23.4" id="ln0050"/></ce:figure><ce:figure id="fg0060"><ce:label>Fig. 6</ce:label><ce:caption id="cp0060"><ce:simple-para id="sp0060">Comparison of (<ce:italic>ϵ</ce:italic> − <ce:italic>ϵ</ce:italic><ce:inf>hooi</ce:inf>)/<ce:italic>ϵ</ce:italic><ce:inf>hooi</ce:inf> for approximations of 100 independent random tensors of dimension 10 × 10 × 100 × 100 truncated to dimension 10 × 10 × 10 × 10 using HOSVD, the Xie method, SuperQ and ISQ. The tensor elements are chosen randomly from a uniform distribution over [0,1] (left plot) and from a Gaussian distribution <ce:italic>N</ce:italic>(0;1) (right plot). The horizontal axis represents different random tensors.</ce:simple-para></ce:caption><ce:alt-text role="short" id="at0060">Fig. 6</ce:alt-text><ce:link locator="gr006" xlink:type="simple" xlink:href="pii:S0550321323000366/gr006" xlink:role="http://data.elsevier.com/vocabulary/ElsevierContentTypes/23.4" id="ln0060"/></ce:figure><ce:figure id="fg0070"><ce:label>Fig. 7</ce:label><ce:caption id="cp0070"><ce:simple-para id="sp0070">Comparison of (<ce:italic>ϵ</ce:italic> − <ce:italic>ϵ</ce:italic><ce:inf>hooi</ce:inf>)/<ce:italic>ϵ</ce:italic><ce:inf>hooi</ce:inf> for random tensors of dimension 30 × 30 × 30 × 30 truncated to dimension 10 × 10 × 10 × 10, using the same approximation methods and the same probability distributions for the tensor elements as in <ce:cross-ref refid="fg0060" id="crf0100">Fig. 6</ce:cross-ref>.</ce:simple-para></ce:caption><ce:alt-text role="short" id="at0070">Fig. 7</ce:alt-text><ce:link locator="gr007" xlink:type="simple" xlink:href="pii:S0550321323000366/gr007" xlink:role="http://data.elsevier.com/vocabulary/ElsevierContentTypes/23.4" id="ln0070"/></ce:figure></ce:floats><head><ce:title id="ti0010">Improved local truncation schemes for the higher-order tensor renormalization group method</ce:title><ce:author-group id="ag0010"><ce:author orcid="0000-0002-8443-4804" id="au0010" author-id="S0550321323000366-90624b61ad93431930b6562552c19df0"><ce:given-name>Jacques</ce:given-name><ce:surname>Bloch</ce:surname><ce:cross-ref refid="aff0010" id="crf0110"><ce:sup>a</ce:sup></ce:cross-ref><ce:e-address type="email" xlink:href="mailto:jacques.bloch@ur.de" id="ea0010">jacques.bloch@ur.de</ce:e-address></ce:author><ce:author id="au0020" author-id="S0550321323000366-fe5401542e27ee7a6c5d41c731520f95"><ce:given-name>Robert</ce:given-name><ce:surname>Lohmayer</ce:surname><ce:cross-ref refid="aff0010" id="crf0120"><ce:sup>a</ce:sup></ce:cross-ref><ce:cross-ref refid="aff0020" id="crf0130"><ce:sup>b</ce:sup></ce:cross-ref><ce:e-address type="email" xlink:href="mailto:robert.lohmayer@ur.de" id="ea0020">robert.lohmayer@ur.de</ce:e-address></ce:author><ce:author id="au0030" author-id="S0550321323000366-1b6acdaa5f29277a4d5e446535dfa32c"><ce:given-name>Maximilian</ce:given-name><ce:surname>Meister</ce:surname><ce:cross-ref refid="aff0010" id="crf0140"><ce:sup>a</ce:sup></ce:cross-ref></ce:author><ce:author id="au0040" author-id="S0550321323000366-ec2957601dd286a31c9014e12efc3769"><ce:given-name>Michael</ce:given-name><ce:surname>Nunhofer</ce:surname><ce:cross-ref refid="aff0010" id="crf0150"><ce:sup>a</ce:sup></ce:cross-ref></ce:author><ce:affiliation id="aff0010" affiliation-id="S0550321323000366-e3a23c135363bac74bbab5d41f20f508"><ce:label>a</ce:label><ce:textfn>Institute for Theoretical Physics, University of Regensburg, 93040 Regensburg, Germany</ce:textfn><sa:affiliation><sa:organization>Institute for Theoretical Physics</sa:organization><sa:organization>University of Regensburg</sa:organization><sa:city>Regensburg</sa:city><sa:postal-code>93040</sa:postal-code><sa:country>Germany</sa:country></sa:affiliation><ce:source-text id="srct0005">Institute for Theoretical Physics, University of Regensburg, 93040 Regensburg, Germany</ce:source-text></ce:affiliation><ce:affiliation id="aff0020" affiliation-id="S0550321323000366-3425d587d16c5d27239eb2362996a3b9"><ce:label>b</ce:label><ce:textfn>Leibniz Institute for Immunotherapy (LIT), 93053 Regensburg, Germany</ce:textfn><sa:affiliation><sa:organization>Leibniz Institute for Immunotherapy (LIT)</sa:organization><sa:city>Regensburg</sa:city><sa:postal-code>93053</sa:postal-code><sa:country>Germany</sa:country></sa:affiliation><ce:source-text id="srct0010">Leibniz Institute for Immunotherapy (LIT), 93053 Regensburg, Germany</ce:source-text></ce:affiliation></ce:author-group><ce:date-received day="5" month="10" year="2022"/><ce:date-revised day="12" month="1" year="2023"/><ce:date-accepted day="1" month="2" year="2023"/><ce:miscellaneous id="ms0010">Editor: Hubert Saleur</ce:miscellaneous><ce:abstract id="ab0010"><ce:section-title id="st0010">Abstract</ce:section-title><ce:abstract-sec id="as0010"><ce:simple-para id="sp0080">The higher-order tensor renormalization group is a tensor-network method providing estimates for the partition function and thermodynamical observables of classical and quantum systems in thermal equilibrium. At every step of the iterative blocking procedure, the coarse-grid tensor is truncated to keep the tensor dimension under control. For a consistent tensor blocking procedure, it is crucial that the forward and backward tensor modes are projected on the same lower dimensional subspaces. In this paper we present two methods, the SuperQ and the iterative SuperQ method, to construct tensor truncations that reduce or even minimize the local approximation errors, while satisfying this constraint.</ce:simple-para></ce:abstract-sec></ce:abstract><ce:data-availability id="dav0001"><ce:section-title id="st0100">Data availability</ce:section-title><ce:para id="pr0590">Data will be made available on request.</ce:para></ce:data-availability></head><body><ce:sections><ce:section id="se0010" role="introduction"><ce:label>1</ce:label><ce:section-title id="st0020">Introduction</ce:section-title><ce:para id="pr0010">Physical systems in thermal equilibrium are described by their partition function, whose complexity grows exponentially in the volume. The standard method to simulate such statistical systems is the Markov chain Monte Carlo method (MC), which efficiently samples the relevant states of the system to produce reliable estimates of observables. A fundamental prerequisite for the MC method is the positivity of the sampling weights. Models which do not satisfy this condition cause the infamous sign problem and require alternative simulation methods. Quantum systems with complex actions are typical examples of systems with a sign problem. An important topical application in high energy physics is the simulation of quantum chromodynamics (QCD) at nonzero quark chemical potential, which allows for the investigation of the QCD phase diagram as a function of temperature and baryon density.</ce:para><ce:para id="pr0020">There exist numerous methods to circumvent the sign problem, and some even solve it for particular systems <ce:cross-refs refid="br0010 br0020 br0030" id="crs0010">[1–3]</ce:cross-refs>. Very mild sign problems can be circumvented by reweighting, which uses the Monte Carlo method on an auxiliary ensemble with positive weights, and reweights the observables to the target ensemble. The main issue with this method is that the statistical error increases exponentially with the volume such that it is hardly usable in any realistic situation, except for the validation of other methods in regions where the sign problem is small. Other methods which have shown their merit on some models, but are known to have fundamental problems for other ones, are the complex Langevin method, the thimbles, the density of states method and the method of dual variables, where the simulations are usually performed with the worm algorithm. Common to those methods is the stochastic sampling of the partition function.</ce:para><ce:para id="pr0030">An alternative approach that has recently drawn a lot of interest is that of tensor networks, see <ce:cross-ref refid="br0040" id="crf0160">[4]</ce:cross-ref> for a review. In these methods the partition function is first rewritten as a full contraction of a tensor network covering the entire lattice. The exact computation of the partition function and observables in this formulation would have an exponential complexity. The tensor renormalization group (TRG) <ce:cross-ref refid="br0050" id="crf0170">[5]</ce:cross-ref> and higher order tensor renormalization group (HOTRG) <ce:cross-ref refid="br0060" id="crf0180">[6]</ce:cross-ref> methods avoid this exponential cost by blocking the lattice iteratively and truncating the inflated dimensions of the coarse grid tensor at each blocking step using truncated higher order singular value decompositions (HOSVD) <ce:cross-ref refid="br0070" id="crf0190">[7]</ce:cross-ref>, which are based on the matrix singular value decomposition (SVD).</ce:para><ce:para id="pr0040">We consider the partition function of a <ce:italic>d</ce:italic>-dimensional classical or quantum system in thermal equilibrium, written as a fully contracted tensor network <ce:cross-ref refid="br0080" id="crf0200">[8]</ce:cross-ref>,<ce:display><ce:formula id="fm0010"><ce:label>(1)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si1.svg"><mml:mrow><mml:mi>Z</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mi mathvariant="normal">tTr</mml:mi><mml:mspace width="0.2em"/><mml:munderover><mml:mo movablelimits="false">∏</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:munderover><mml:msubsup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> with a tensor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si2.svg"><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> at each site <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si3.svg"><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>V</mml:mi></mml:math>. In general the local tensor is the same on all sites, i.e., <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si4.svg"><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>T</mml:mi></mml:math> for all <ce:italic>x</ce:italic>. For each lattice direction <ce:italic>ν</ce:italic>, the tensor has one mode for the forward and one mode for the backward orientation, corresponding to the indices <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si5.svg"><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si6.svg"><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo>≡</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>ν</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo>,</mml:mo><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math>, respectively, where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si7.svg"><mml:mover accent="true"><mml:mrow><mml:mi>ν</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> is a unit step in the <ce:italic>ν</ce:italic> direction. We will often refer to these modes as backward and forward modes of the physical tensor. The trace in the partition function stands for a full contraction over all tensor indices, where two adjacent tensors share exactly one index.</ce:para><ce:para id="pr0050">Thermodynamical observables, which are defined as derivatives of the partition function with respect to one of its parameters, can be computed using either a finite-difference approximation or an impurity tensor formulation involving the analytical derivative of <ce:italic>T</ce:italic> <ce:cross-ref refid="br0090" id="crf0210">[9]</ce:cross-ref>.</ce:para><ce:para id="pr0060">In the following we will restrict our discussion to HOTRG, because it can be applied to any number of dimensions, whereas TRG is limited to two-dimensional systems. The HOTRG method uses an iterative blocking procedure that reduces the size of the lattice by a factor of two during each blocking step by contracting pairs of adjacent tensors. The procedure is illustrated for a two-dimensional <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si8.svg"><mml:mn>4</mml:mn><mml:mo>×</mml:mo><mml:mn>4</mml:mn></mml:math> lattice in <ce:cross-ref refid="fg0010" id="crf0220">Fig. 1</ce:cross-ref><ce:float-anchor refid="fg0010"/>. Its extension to higher dimensions is obvious, and below we will further discuss the HOTRG method for the three-dimensional case.</ce:para><ce:para id="pr0070">When contracting two adjacent tensors <ce:italic>T</ce:italic> over their shared link, a tensor <ce:italic>M</ce:italic> of higher order is produced. Such a contraction in the 1-direction is illustrated for the three-dimensional case in <ce:cross-ref refid="fg0020" id="crf0230">Fig. 2</ce:cross-ref><ce:float-anchor refid="fg0020"/> and can be written as<ce:display><ce:formula id="fm0020"><ce:label>(2)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si9.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mspace width="0.2em"/><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></ce:formula></ce:display> where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si10.svg"><mml:mi>y</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mover accent="true"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> and therefore <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si11.svg"><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>, by definition, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si12.svg"><mml:mi>X</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math> labels sites on the coarse grid and<ce:display><ce:formula id="fm0030"><ce:label>(3)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si13.svg"><mml:mrow><mml:mtable displaystyle="true" columnspacing="0.2em"><mml:mtr><mml:mtd columnalign="right"/><mml:mtd columnalign="left"><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mspace width="2em"/><mml:mspace width="2em"/><mml:mspace width="0.2em"/><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"/><mml:mtd columnalign="left"><mml:mtable displaystyle="true" columnspacing="0.2em"><mml:mtr><mml:mtd columnalign="right"/><mml:mtd columnalign="left"><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd><mml:mtd columnalign="right"/><mml:mtd columnalign="left"><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"/><mml:mtd columnalign="left"><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd><mml:mtd columnalign="right"/><mml:mtd columnalign="left"><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable><mml:mspace width="1em"/><mml:mo stretchy="true" maxsize="6.6ex" minsize="6.6ex">}</mml:mo><mml:mspace width="1em"/><mml:mrow><mml:mtext mathvariant="bold">fat</mml:mtext><mml:mspace width="0.25em"/><mml:mtext>indices</mml:mtext></mml:mrow><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></ce:formula></ce:display> For any direction perpendicular to the direction of contraction, the tensor <ce:italic>M</ce:italic> has modes originating from both contracted tensors. To keep the order of the tensor unchanged, we gather every such pair of modes in a new fat mode corresponding to its direct product space. Assuming that the modes of the local tensor have dimension <ce:italic>D</ce:italic>, then the fat modes will have dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si14.svg"><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>. In HOTRG these fat modes are truncated back to dimension <ce:italic>D</ce:italic> using a modified version of the HOSVD approximation method, such that the dimension of the coarse grid tensor remains the same as that of the original local tensor throughout the entire blocking procedure.</ce:para><ce:para id="pr0080">In general, step <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si15.svg"><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math> of the HOTRG procedure can be summarized as<ce:display><ce:formula id="fm0040"><ce:label>(4)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si16.svg"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⋆</mml:mo></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mo>:</mml:mo><mml:mi>M</mml:mi><mml:mover accent="true"><mml:mrow><mml:mo stretchy="false">⟶</mml:mo></mml:mrow><mml:mrow><mml:mtext>truncate</mml:mtext></mml:mrow></mml:mover><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> where the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si17.svg"><mml:msub><mml:mrow><mml:mo>⋆</mml:mo></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math>-operation symbolically represents a forward-backward contraction in direction <ce:italic>ν</ce:italic>. The precise construction of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si18.svg"><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msup></mml:math> will be discussed in Sec. <ce:cross-ref refid="se0030" id="crf0240">3</ce:cross-ref>.</ce:para><ce:para id="pr0090">In the standard approximation procedure using HOSVD <ce:cross-ref refid="br0070" id="crf0250">[7]</ce:cross-ref>, referred to as <ce:italic>HOSVD approximation</ce:italic> in the following, the dimension of each tensor mode gets reduced by projecting it on a lower dimensional subspace, which is generically different for each mode. This HOSVD approximation is modified when used as part of the iterative blocking procedure in the standard HOTRG algorithm, as it is essential for the accuracy and effectiveness of the method that the backward and forward modes for every direction get projected on the same subspace. Each of these subspaces will be characterized by a frame, which is a set of orthonormal basis vectors spanning the subspace. Constructing appropriate frames will be the major subject of this paper.</ce:para><ce:para id="pr0100">The standard HOTRG procedure for the construction of frames <ce:cross-ref refid="br0060" id="crf0260">[6]</ce:cross-ref> is not optimal, in particular when the local tensor is not symmetric in its backward and forward modes. In this paper we present two improved methods for the construction of common subspaces for pairs of backward and forward modes: the <ce:italic>SuperQ</ce:italic> and the <ce:italic>iterative SuperQ</ce:italic> method (ISQ), which is an iterative improvement of the former in search of the optimal subspaces. Note that the discussion in this paper solely focuses on the optimization of the rank reduction of the local tensors at every blocking step, but does not take into account global effects on the full contraction of the tensor network.</ce:para><ce:para id="pr0110">Here is a brief outline of the paper. In Sec. <ce:cross-ref refid="se0020" id="crf0270">2</ce:cross-ref> we review the standard HOSVD method to construct a reduced rank approximation for an arbitrary tensor. In Sec. <ce:cross-ref refid="se0030" id="crf0280">3</ce:cross-ref> we explain why the HOTRG method uses a modification of this rank reduction procedure such that the backward and forward modes are projected on the same subspace. We then propose two methods to improve the standard HOTRG truncation: In Sec. <ce:cross-ref refid="se0040" id="crf0290">4</ce:cross-ref> we present the SuperQ method, and in Sec. <ce:cross-ref refid="se0050" id="crf0300">5</ce:cross-ref> we derive the more sophisticated ISQ method. Finally, we summarize and conclude in Sec. <ce:cross-ref refid="se0070" id="crf0310">7</ce:cross-ref>.</ce:para></ce:section><ce:section id="se0020"><ce:label>2</ce:label><ce:section-title id="st0030">Rank reduction and HOSVD approximation</ce:section-title><ce:para id="pr0120">Below we first review the general idea of rank reduction for an arbitrary tensor, before describing the HOSVD procedure <ce:cross-ref refid="br0070" id="crf0320">[7]</ce:cross-ref> which can be used to generate a quasi-optimal rank-reduced approximation in an efficient way.</ce:para><ce:para id="pr0130">For a real tensor <ce:italic>M</ce:italic> of order <ce:italic>n</ce:italic> with dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si19.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mo>⋯</mml:mo><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math>, the left <ce:italic>matrix-tensor multiplication</ce:italic> <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si20.svg"><mml:mi>A</mml:mi><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mi>M</mml:mi></mml:math> is defined as a contraction of the second index of the matrix <ce:italic>A</ce:italic> with the <ce:italic>r</ce:italic>-th index of the tensor <ce:italic>M</ce:italic>,<ce:display><ce:formula id="fm0050"><ce:label>(5)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si21.svg"><mml:mrow><mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></ce:formula></ce:display></ce:para><ce:para id="pr0140">A lower-rank approximation of <ce:italic>M</ce:italic> can be constructed as<ce:display><ce:formula id="fm0060"><ce:label>(6)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si22.svg"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>M</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> using <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si23.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math> projectors <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si24.svg"><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> of rank <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si25.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si26.svg"><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:math>. In this approximation, the <ce:italic>r</ce:italic>-th tensor mode of dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si27.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math> is projected onto a subspace of dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si28.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math>, embedded in the original space. Typically the Frobenius norm <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si29.svg"><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">‖</mml:mo></mml:math> is used as a measure for the quality of the low-rank approximation and the aim is to determine optimal projectors <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si24.svg"><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> with fixed ranks <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si28.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math>.</ce:para><ce:para id="pr0150">The projectors can be represented as<ce:display><ce:formula id="fm0070"><ce:label>(7)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si30.svg"><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup></mml:mrow></mml:math></ce:formula></ce:display> with semi-orthogonal <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si31.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math> matrices <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si32.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, which we will call <ce:italic>frames</ce:italic> in the following. Semi-orthogonal means that the columns of the frames are orthonormal, but not their rows (unless <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si33.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math>). The columns of each frame <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si32.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> provide an orthonormal basis of the corresponding <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si28.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math>-dimensional subspace,<ce:display><ce:formula id="fm0080"><ce:label>(8)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si34.svg"><mml:mrow><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="double-struck">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></ce:formula></ce:display></ce:para><ce:para id="pr0160">The approximation <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> can then be rewritten as<ce:display><ce:formula id="fm0090"><ce:label>(9)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si36.svg"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>S</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> with the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si37.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mo>…</mml:mo><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math> dimensional <ce:italic>core tensor</ce:italic><ce:display><ce:formula id="fm0100"><ce:label>(10)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si38.svg"><mml:mrow><mml:mi>S</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>M</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> The core tensor represents <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> in the bases of the subspaces, which are spanned by the columns of the frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si32.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>. Note that <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> has the same dimension as <ce:italic>M</ce:italic>, but is generically of lower rank as the <ce:italic>r</ce:italic>-th mode is projected from a space of dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si27.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math> on a subspace of dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si28.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math> for <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si26.svg"><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:math>. In practice, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> is usually not constructed explicitly, as many operations involving <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> can be performed at much lower cost using only the core tensor <ce:italic>S</ce:italic> and the frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si32.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, which contain the same information as <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> but condensed in lower-dimensional objects. A typical example of such an operation is the contraction of two tensors, as will be discussed in the next section.</ce:para><ce:para id="pr0170">The squared Frobenius norm of <ce:italic>M</ce:italic> is given by<ce:display><ce:formula id="fm0110"><ce:label>(11)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si40.svg"><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="false">〈</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">〉</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> where for brevity we introduce the notation <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si41.svg"><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math> for the summation indices, and the inner product between two real tensors of equal dimension is defined as<ce:display><ce:formula id="fm0120"><ce:label>(12)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si42.svg"><mml:mrow><mml:mrow><mml:mo stretchy="false">〈</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">〉</mml:mo></mml:mrow><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></ce:formula></ce:display></ce:para><ce:para id="pr0180">Since the reduced-rank tensor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> is a projection of <ce:italic>M</ce:italic>, we have<ce:display><ce:formula id="fm0130"><ce:label>(13)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si43.svg"><mml:mrow><mml:mrow><mml:mo stretchy="false">〈</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">〉</mml:mo></mml:mrow><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> Therefore, the squared approximation error is given by<ce:display><ce:formula id="fm0140"><ce:label>(14)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si44.svg"><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn><mml:mrow><mml:mo stretchy="false">〈</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">〉</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> which does not require the explicit computation of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math>.</ce:para><ce:para id="pr0190">In the HOSVD approximation procedure <ce:cross-ref refid="br0070" id="crf0330">[7]</ce:cross-ref> the semi-orthogonal frames used to approximate <ce:italic>M</ce:italic> are constructed using properties of matrix SVDs. We first introduce the <ce:italic>r</ce:italic>-unfolding <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si45.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, which is a matrix containing the same entries as the tensor <ce:italic>M</ce:italic>, but reordered such that its rows correspond to the <ce:italic>r</ce:italic>-th mode of <ce:italic>M</ce:italic> and its columns correspond to a combination of all other tensor modes. The entries of the <ce:italic>r</ce:italic>-unfolding of <ce:italic>M</ce:italic> are given by<ce:display><ce:formula id="fm0150"><ce:label>(15)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si46.svg"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.2em"/><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> where the column index <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si47.svg"><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math> is a linear index of coordinates in a space of dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si48.svg"><mml:msub><mml:mrow><mml:mo>∏</mml:mo></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>≠</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:math>. The multi-rank of a tensor is defined by the <ce:italic>n</ce:italic>-tuple of the ranks of the individual unfoldings <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si45.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si26.svg"><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:math>. Therefore <ce:italic>M</ce:italic> has at most multi-rank <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si49.svg"><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math> and the approximation <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> of <ce:cross-ref refid="fm0060" id="crf0340">(6)</ce:cross-ref> at most multi-rank <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si50.svg"><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math>. Note that the squared Frobenius norm <ce:cross-ref refid="fm0110" id="crf0350">(11)</ce:cross-ref> of a tensor is identical to that of any of its unfoldings, as it is just a sum over all squared components,<ce:display><ce:formula id="fm0160"><ce:label>(16)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si51.svg"><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi mathvariant="normal">Tr</mml:mi><mml:mspace width="0.2em"/><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="true">]</mml:mo></mml:mrow></mml:mrow></mml:math></ce:formula></ce:display> for any <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si26.svg"><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:math>. To construct the HOSVD approximation <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math>, we first consider the singular value decomposition for each <ce:italic>r</ce:italic>-unfolding <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si45.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> of <ce:italic>M</ce:italic> (assuming real tensors for simplicity),<ce:display><ce:formula id="fm0170"><ce:label>(17)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si52.svg"><mml:mrow><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> where the columns of the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si23.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math> orthogonal matrix <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si53.svg"><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> are the left singular vectors of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si45.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>. The columns of the orthogonal matrix <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si54.svg"><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> contain the corresponding right singular vectors of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si45.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>. The diagonal entries of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si55.svg"><mml:msup><mml:mrow><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> are the singular values of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si45.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, which are always real and non-negative, while all other entries are zero.</ce:para><ce:para id="pr0200">It is well-known in linear algebra that retaining the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si28.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math> largest singular values in <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si55.svg"><mml:msup><mml:mrow><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, while setting all others to zero, yields the best-possible matrix approximation <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si56.svg"><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> of rank <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si28.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math> to <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si45.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> (best-possible referring to a minimization of the Frobenius norm <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si57.svg"><mml:mo stretchy="false">‖</mml:mo><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">‖</mml:mo></mml:math>). The relative truncation error is given by<ce:display><ce:formula id="fm0180"><ce:label>(18)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si58.svg"><mml:mrow><mml:msup><mml:mrow><mml:mi>ϵ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mfrac><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">‖</mml:mo></mml:mrow></mml:mfrac><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msqrt><mml:mrow><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:msqrt><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si59.svg"><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> are the eigenvalues of the Gramian <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si60.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup></mml:math>, i.e., the squared singular values of the unfolding <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si45.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, ordered such that <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si61.svg"><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>≥</mml:mo><mml:mo>…</mml:mo><mml:mo>≥</mml:mo><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math>.</ce:para><ce:para id="pr0210">This matrix property is used in HOSVD by separately performing the matrix SVDs of all individual unfoldings <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si45.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> of <ce:italic>M</ce:italic> for <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si26.svg"><mml:mi>r</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:math> and constructing the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si31.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math> frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si32.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> with the singular vectors of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si53.svg"><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> corresponding to the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si28.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math> largest singular values of the unfoldings <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si45.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>. These frames are then used to construct the core tensor <ce:cross-ref refid="fm0100" id="crf0360">(10)</ce:cross-ref> and the matrix approximation <ce:cross-ref refid="fm0090" id="crf0370">(9)</ce:cross-ref> of HOSVD. Unlike for the matrix case, the HOSVD tensor approximation is in general not the best-possible approximation of a given multi-rank <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si50.svg"><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math>, even though it is usually quite close to it <ce:cross-ref refid="br0070" id="crf0380">[7]</ce:cross-ref>.</ce:para><ce:para id="pr0220">In a variant of the HOSVD approximation, called interlaced HOSVD approximation, the rank reduction procedure is carried out in the following way: Starting with <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si62.svg"><mml:mi>S</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>M</mml:mi></mml:math>, the frames are computed on successive unfoldings of the core tensor, which gets updated every time a new truncation frame is constructed until the core tensor is of dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si63.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mo>…</mml:mo><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math>. For the interlaced HOSVD approximation, the result depends on the order of the updates, but is usually close to that of the ordinary HOSVD approximation.</ce:para><ce:para id="pr0230">The best-possible approximation of multi-rank <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si50.svg"><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math>, which minimizes the Frobenius norm <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si29.svg"><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">‖</mml:mo></mml:math>, can be constructed numerically using the Higher Order Orthogonal Iteration (HOOI) <ce:cross-ref refid="br0100" id="crf0390">[10]</ce:cross-ref>. Nevertheless, the HOSVD approximation is especially appealing because of its relative simplicity to produce an almost optimal approximation.</ce:para></ce:section><ce:section id="se0030"><ce:label>3</ce:label><ce:section-title id="st0040">Backward-forward symmetric truncation in HOTRG</ce:section-title><ce:para id="pr0240">We now discuss how the HOSVD formalism is used in HOTRG to avoid the exponential blow up of the tensor dimension during the blocking procedure, and why the standard HOSVD truncation is modified to avoid drawbacks related to accuracy and efficiency. To make our point we will use the two-dimensional case as it can be easiest illustrated and contains all the ingredients necessary for the discussion. Extending it to higher dimensions is straightforward.</ce:para><ce:para id="pr0250">We consider the contraction <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si64.svg"><mml:mi>M</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>⋆</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>T</mml:mi></mml:math> of two local tensors <ce:italic>T</ce:italic> along the 2-direction. According to the discussion in the introduction, <ce:italic>M</ce:italic> will have thin backward and forward modes of dimension <ce:italic>D</ce:italic> in the contracted 2-direction, and fat backward and forward modes of dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si14.svg"><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math> in the perpendicular 1-direction, which we want to reduce to lower rank by projecting on a <ce:italic>D</ce:italic>-dimensional subspace using <ce:cross-ref refid="fm0060" id="crf0400">(6)</ce:cross-ref>. This procedure of contraction and truncation, which we detail below, is illustrated in <ce:cross-ref refid="fg0030" id="crf0410">Fig. 3</ce:cross-ref><ce:float-anchor refid="fg0030"/>. To reduce the dimension of the fat modes back from <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si14.svg"><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math> to <ce:italic>D</ce:italic>, while minimizing the loss of information, we apply the HOSVD approximation procedure, explained in Sec. <ce:cross-ref refid="se0020" id="crf0420">2</ce:cross-ref>, where we only truncate the fat modes. The SVDs are computed for the unfoldings <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si65.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si66.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> for the backward and forward modes in the 1-direction, respectively, and the frames <ce:italic>U</ce:italic> and <ce:italic>V</ce:italic> of dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si67.svg"><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:mi>D</mml:mi></mml:math> are constructed with the singular vectors corresponding to their <ce:italic>D</ce:italic> largest singular values. For the modes in the contracted 2-direction no truncation is required. With these frames we construct a core tensor <ce:italic>S</ce:italic> of dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si68.svg"><mml:mi>D</mml:mi><mml:mo>×</mml:mo><mml:mi>D</mml:mi><mml:mo>×</mml:mo><mml:mi>D</mml:mi><mml:mo>×</mml:mo><mml:mi>D</mml:mi></mml:math>, according to <ce:cross-ref refid="fm0100" id="crf0430">(10)</ce:cross-ref>,<ce:display><ce:formula id="fm0190"><ce:label>(19)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si69.svg"><mml:mrow><mml:mi>S</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>M</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> The corresponding approximation <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math>, defined in <ce:cross-ref refid="fm0090" id="crf0440">(9)</ce:cross-ref>, with the same dimension as <ce:italic>M</ce:italic>, but typically much lower rank, is given by<ce:display><ce:formula id="fm0200"><ce:label>(20)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si70.svg"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mi>U</mml:mi><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>V</mml:mi><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>S</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>U</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>M</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> with <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si71.svg"><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math> projectors <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si72.svg"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>U</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>U</mml:mi><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si73.svg"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>V</mml:mi><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:math>, with <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si74.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>U</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>V</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="double-struck">1</mml:mn></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:math>. As mentioned in Sec. <ce:cross-ref refid="se0020" id="crf0450">2</ce:cross-ref>, operations involving <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> can typically be performed at much lower cost by using only the core tensor <ce:italic>S</ce:italic> and the frames <ce:italic>U</ce:italic> and <ce:italic>V</ce:italic>.</ce:para><ce:para id="pr0260">Assume that in the next blocking step two <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> tensors are contracted in the 1-direction, as is illustrated in <ce:cross-ref refid="fg0040" id="crf0460">Fig. 4</ce:cross-ref><ce:float-anchor refid="fg0040"/>. When using the standard HOSVD approximation <ce:cross-ref refid="fm0200" id="crf0470">(20)</ce:cross-ref> the backward and forward modes in <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> will have been projected on different subspaces using the projectors <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si75.svg"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>U</mml:mi></mml:mrow></mml:msub></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si76.svg"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:msub></mml:math>, respectively. In a contraction <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si77.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:msub><mml:mrow><mml:mo>⋆</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> the two projectors will be multiplied, as can be seen in the center of the figure. The decomposition of the approximation <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> in <ce:cross-ref refid="fm0200" id="crf0480">(20)</ce:cross-ref> can be used to reduce the computational effort, as the original contraction can be replaced by contractions of two core tensors <ce:italic>S</ce:italic> with a <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si78.svg"><mml:mi>D</mml:mi><mml:mo>×</mml:mo><mml:mi>D</mml:mi></mml:math> dimensional merger <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si79.svg"><mml:mi>G</mml:mi><mml:mo>≡</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mi>V</mml:mi></mml:math> in between, as can be seen in the figure.<ce:cross-ref refid="fn0010" id="crf0490"><ce:sup>1</ce:sup></ce:cross-ref><ce:footnote id="fn0010"><ce:label>1</ce:label><ce:note-para id="np0010">In fact this produces an amputated version of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si77.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:msub><mml:mrow><mml:mo>⋆</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math>, which together with the mergers is all we need in the full contraction of the tensor network, see also <ce:cross-ref refid="fg0040" id="crf0500">Fig. 4</ce:cross-ref>.</ce:note-para></ce:footnote> The entries of <ce:italic>G</ce:italic> are scalar products of the basis vectors in <ce:italic>U</ce:italic> and <ce:italic>V</ce:italic>.</ce:para><ce:para id="pr0270">At this point it is important to discuss a crucial modification introduced by the HOTRG method to the HOSVD truncation procedure presented above, which is rarely discussed in the literature. Although the HOSVD approximation <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> gives a close-to-best lower-rank approximation to <ce:italic>M</ce:italic>, it is in general not such a good and useful truncation when viewed as part of the iterative blocking procedure. Indeed, the product of projectors corresponds to a projection of a projection, which will unavoidably loose additional information if the projectors <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si75.svg"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>U</mml:mi></mml:mrow></mml:msub></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si76.svg"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:msub></mml:math> are different. In this case, the contraction <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si77.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:msub><mml:mrow><mml:mo>⋆</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> will no longer necessarily be a good approximation of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si80.svg"><mml:mi>M</mml:mi><mml:msub><mml:mrow><mml:mo>⋆</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>M</mml:mi></mml:math>, even if <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> itself was close to the best-possible approximation of <ce:italic>M</ce:italic>.</ce:para><ce:para id="pr0280">We now observe that, due to the idempotence of projectors, there would be no additional loss if <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si81.svg"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>U</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:msub></mml:math>, i.e., if the backward and forward modes of <ce:italic>M</ce:italic> in the 1-direction were projected on the same subspace. Note that in this case the merger <ce:italic>G</ce:italic> is an orthogonal matrix. Moreover, we can also get a serious gain in algorithmic simplicity, on top of this accuracy improvement, if we choose the same basis for both modes in the common subspace, i.e., we choose frames satisfying <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si82.svg"><mml:mi>U</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>V</mml:mi></mml:math>, for which <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si83.svg"><mml:mi>G</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="double-struck">1</mml:mn></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:math>. When looking back at <ce:cross-ref refid="fg0040" id="crf0510">Fig. 4</ce:cross-ref> we see that, in this case, the central merger just drops out, and the contraction can be replaced by a contraction of two core tensors, as is illustrated in <ce:cross-ref refid="fg0050" id="crf0520">Fig. 5</ce:cross-ref><ce:float-anchor refid="fg0050"/> (the frames on the left and right of <ce:cross-ref refid="fg0040" id="crf0530">Fig. 4</ce:cross-ref> will connect to their counter parts in further contractions, to form another merger <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si83.svg"><mml:mi>G</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="double-struck">1</mml:mn></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:math>, which will also drop out).</ce:para><ce:para id="pr0290">For this reason, in HOTRG the backward and forward modes of each direction are truncated using a common frame <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si166.svg"><mml:mi>ν</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:math>, even when the HOSVD frames are different, which is typically the case for systems at nonzero chemical potential. With this backward-forward symmetric truncation, the core tensor <ce:italic>S</ce:italic> can be used as new coarse grid tensor after each blocking step, where at the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si86.svg"><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math>-th blocking step two tensors of step <ce:italic>k</ce:italic> are contracted to form a new coarse grid tensor,<ce:display><ce:formula id="fm0210"><ce:label>(21)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si87.svg"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⋆</mml:mo></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mo>:</mml:mo><mml:mi>M</mml:mi><mml:mover accent="true"><mml:mrow><mml:mo stretchy="false">⟶</mml:mo></mml:mrow><mml:mrow><mml:mtext>BF</mml:mtext></mml:mrow></mml:mover><mml:mi>S</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>:</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> The abbreviation BF on the arrow means that we apply a backward-forward symmetric truncation to construct the core tensor, which then becomes the new local tensor on the coarse grid. The frames are only needed to construct the core tensor with <ce:cross-ref refid="fm0190" id="crf0540">(19)</ce:cross-ref>, and can then be discarded.</ce:para><ce:para id="pr0300">The same reasoning also holds for a contraction in the other direction, where the directions of thin and fat modes are interchanged. Moreover, the procedure naturally generalizes to <ce:italic>d</ce:italic> dimensions, where we have <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si88.svg"><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math> directions <ce:italic>ν</ce:italic> with backward and forward fat modes: If the backward and forward frames are chosen to be identical for each direction, the core tensor <ce:cross-ref refid="fm0100" id="crf0550">(10)</ce:cross-ref> can be used as the new coarse grid tensor in the HOTRG blocking procedure.</ce:para><ce:para id="pr0310">This strategy of choosing the same frame to truncate the backward and forward mode for each individual direction in HOTRG, makes it fundamentally different from the HOSVD approximation, as it can no longer directly rely on the optimal low-rank properties of matrix SVD. Geometrically, truncating the backward and forward modes with the same frame means that these modes get projected on the same subspace and are described in the same basis. This explains why the full contraction of the tensor network into a scalar can be rewritten in terms of the core tensors only.</ce:para><ce:para id="pr0320">Note that if one would use the standard HOSVD approximation procedure and work with different backward and forward frames, we would have to use both the core tensors and the mergers <ce:italic>G</ce:italic> defined above when performing the iterative contractions, to ensure that the different subspaces are matched onto one another, see <ce:cross-ref refid="fg0040" id="crf0560">Fig. 4</ce:cross-ref>. Although this is no conceptual problem, it would complicate the algorithm, require additional computational work, and most of all the product of projectors would deteriorate the results further.</ce:para><ce:para id="pr0330">The construction of the shared backward-forward frames in HOTRG has not been given a lot of attention in the literature until now. There is a brief discussion of this issue in the original HOTRG paper <ce:cross-ref refid="br0060" id="crf0570">[6]</ce:cross-ref>, where either the backward or forward frame is chosen and applied to both modes, depending on which one gives the smallest SVD truncation error. The error introduced by this choice on the other mode is however not taken into account. We observed that for tensors lacking a backward-forward symmetry, this choice of frame is not optimal and can be improved upon.</ce:para><ce:para id="pr0340">Below we present two new methods to improve the construction of shared frames for the backward and forward modes. The first one, called SuperQ method and presented in Sec. <ce:cross-ref refid="se0040" id="crf0580">4</ce:cross-ref>, minimizes a combined error on the backward and forward unfoldings for each individual direction. The second method, which we call iterative SuperQ (ISQ) method is presented in Sec. <ce:cross-ref refid="se0050" id="crf0590">5</ce:cross-ref>. This iterative method aims at determining the best-possible approximation to <ce:italic>M</ce:italic> for a given multi-rank, satisfying the requirement that the backward and forward frames for each direction are identical. The ISQ method leans on ideas developed for the higher order orthogonal iteration (HOOI) method <ce:cross-ref refid="br0100" id="crf0600">[10]</ce:cross-ref>, which constructs the best-possible approximation of a given multi-rank with independent frames for all modes. We will see that the SuperQ solution can be used as a natural starting point for the ISQ procedure. Note that the SuperQ and ISQ methods are specifically conceived for tensors which are part of a physical tensor network on a space-time lattice and have modes corresponding to backward and forward orientations.</ce:para></ce:section><ce:section id="se0040"><ce:label>4</ce:label><ce:section-title id="st0050">The SuperQ method</ce:section-title><ce:para id="pr0350">To discuss the construction of truncations satisfying the requirement that the frames for the backward and forward modes are identical, we consider a tensor <ce:italic>M</ce:italic> with <ce:italic>d</ce:italic> pairs of backward and forward modes. The tensor is thus of order 2<ce:italic>d</ce:italic> with dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si89.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mo>⋯</mml:mo><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math>, which will be truncated to dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si90.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mo>⋯</mml:mo><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math> using <ce:italic>d</ce:italic> semi-orthogonal frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> of dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si91.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math>. With these frames the core tensor is constructed using<ce:display><ce:formula id="fm0220"><ce:label>(22)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si92.svg"><mml:mrow><mml:mi>S</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>d</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mi>M</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> Consider the positive semi-definite Gram matrices<ce:display><ce:formula id="fm0230"><ce:label>(23)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si93.svg"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mspace width="2em"/><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si104.svg"><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si105.svg"><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> are the unfoldings of <ce:italic>M</ce:italic> with respect to the backward and forward modes for direction <ce:italic>ν</ce:italic>, i.e.,<ce:display><ce:formula id="fm0240"><ce:label>(24)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si96.svg"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>≡</mml:mo><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>ν</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="2em"/><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>≡</mml:mo><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si45.svg"><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> is the <ce:italic>r</ce:italic>-unfolding of the tensor <ce:italic>M</ce:italic> defined in <ce:cross-ref refid="fm0150" id="crf0610">(15)</ce:cross-ref>. We denote the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si91.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math> frames constructed with the eigenvectors corresponding to the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si98.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math> largest eigenvalues of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si99.svg"><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si100.svg"><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> as <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si101.svg"><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si102.svg"><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math>, respectively. As the backward and forward Gramians <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si99.svg"><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si100.svg"><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> are in general not identical, the corresponding subspaces spanned by the vectors of the frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si101.svg"><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si102.svg"><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> will be different too.<ce:cross-ref refid="fn0020" id="crf0620"><ce:sup>2</ce:sup></ce:cross-ref><ce:footnote id="fn0020"><ce:label>2</ce:label><ce:note-para id="np0020">This can even be the case if the eigenvalues of both Gramians coincide, as we have observed for the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si103.svg"><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math> model with chemical potential.</ce:note-para></ce:footnote> In the standard HOTRG procedure <ce:cross-ref refid="br0060" id="crf0630">[6]</ce:cross-ref> it is suggested to choose either <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si101.svg"><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> or <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si102.svg"><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> for the unique <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, depending which of both gives the smallest SVD truncation error <ce:cross-ref refid="fm0180" id="crf0640">(18)</ce:cross-ref>. Even though this choice of frame optimizes the truncation error for one mode, it does not take into account its effect on the mode corresponding to the opposite orientation. Therefore, it is clear that, generically, better choices of frames should exist, and our aim is to construct frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> that reduce the combined truncation error when applied simultaneously to the backward and forward modes for the <ce:italic>ν</ce:italic> direction.</ce:para><ce:para id="pr0360">Let us now consider a single truncation frame <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> which we use to reduce the rank of the unfoldings <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si104.svg"><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si105.svg"><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math>. Using <ce:cross-ref refid="fm0140" id="crf0650">(14)</ce:cross-ref> and <ce:cross-ref refid="fm0160" id="crf0660">(16)</ce:cross-ref>, the relative truncation errors on the backward and forward unfoldings are<ce:display><ce:formula id="fm0250"><ce:label>(25)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si106.svg"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>ϵ</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mfrac><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">‖</mml:mo></mml:mrow></mml:mfrac><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mfrac><mml:mrow><mml:mi mathvariant="normal">Tr</mml:mi><mml:mspace width="0.2em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Tr</mml:mi><mml:mspace width="0.2em"/><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:msqrt><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display><ce:display><ce:formula id="fm0260"><ce:label>(26)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si107.svg"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>ϵ</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mfrac><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">‖</mml:mo></mml:mrow></mml:mfrac><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mfrac><mml:mrow><mml:mi mathvariant="normal">Tr</mml:mi><mml:mspace width="0.2em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Tr</mml:mi><mml:mspace width="0.2em"/><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:msqrt><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si108.svg"><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si109.svg"><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> are the rank-<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si98.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math> approximations to the unfoldings <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si104.svg"><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si105.svg"><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math>, respectively, obtained with the same frame <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>.</ce:para><ce:para id="pr0370">To improve upon using either <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si101.svg"><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> or <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si102.svg"><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math>, we determine the common <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> by minimizing the combination of both errors in<ce:display><ce:formula id="fm0270"><ce:label>(27)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si112.svg"><mml:mrow><mml:msup><mml:mrow><mml:msubsup><mml:mrow><mml:mi>ϵ</mml:mi></mml:mrow><mml:mrow><mml:mtext>S</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:msup><mml:mrow><mml:msubsup><mml:mrow><mml:mi>ϵ</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:msubsup><mml:mrow><mml:mi>ϵ</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mi mathvariant="normal">Tr</mml:mi><mml:mspace width="0.2em"/><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> where we also used <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si113.svg"><mml:mi mathvariant="normal">Tr</mml:mi><mml:mspace width="0.2em"/><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi mathvariant="normal">Tr</mml:mi><mml:mspace width="0.2em"/><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>. We define the SuperQ matrix for direction <ce:italic>ν</ce:italic> as<ce:display><ce:formula id="fm0280"><ce:label>(28)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si114.svg"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>S</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>b</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>f</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> which is symmetric and positive semi-definite as it is a sum of two symmetric positive semi-definite matrices. Therefore, if we diagonalize the SuperQ matrix and truncate the eigenvector matrix, retaining the eigenvectors corresponding to the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si98.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math> largest eigenvalues, then this semi-orthogonal frame <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> minimizes the truncation error <ce:cross-ref refid="fm0270" id="crf0670">(27)</ce:cross-ref> on <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si115.svg"><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext>S</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math>. This SuperQ procedure is repeated on all <ce:italic>d</ce:italic> directions to determine all frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, which can then be used to approximate <ce:italic>M</ce:italic> and to construct the corresponding core tensor <ce:italic>S</ce:italic>, see <ce:cross-ref refid="fm0220" id="crf0680">(22)</ce:cross-ref>.</ce:para><ce:para id="pr0380">The SuperQ method is computationally efficient since it only requires a single eigenvalue decomposition for each pair of backward and forward fat modes, while the standard HOTRG procedure <ce:cross-ref refid="br0060" id="crf0690">[6]</ce:cross-ref> performs separate decompositions on these modes.</ce:para><ce:para id="pr0390">When applying the SuperQ method to HOTRG, where <ce:italic>M</ce:italic> is a contraction <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si116.svg"><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>⋆</mml:mo></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mi>T</mml:mi></mml:math> along one of the directions, only <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si117.svg"><mml:mn>2</mml:mn><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:math> modes will actually be truncated, as the backward and forward modes for the contracted direction need not be truncated.</ce:para><ce:para id="pr0400">In analogy to the interlaced HOSVD approximation, see Sec. <ce:cross-ref refid="se0020" id="crf0700">2</ce:cross-ref>, we can also define an interlaced version of the SuperQ method where we determine the frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> by applying the method to an intermediate core tensor, which gets updated direction-by-direction (starting from <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si62.svg"><mml:mi>S</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>M</mml:mi></mml:math>) by truncating the respective backward and forward mode each time a frame has been computed. This interlaced SuperQ method is also of interest in the light of the iterative procedure derived in the next section.</ce:para></ce:section><ce:section id="se0050"><ce:label>5</ce:label><ce:section-title id="st0060">Optimized frames with iterative SuperQ</ce:section-title><ce:para id="pr0410">Although the HOSVD method, see Sec. <ce:cross-ref refid="se0020" id="crf0710">2</ce:cross-ref>, typically yields a good tensor approximation <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si35.svg"><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover></mml:math> <ce:cross-ref refid="br0070" id="crf0720">[7]</ce:cross-ref>, the best-possible one, which minimizes <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si118.svg"><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>, can be constructed with an iterative procedure called higher order orthogonal iteration (HOOI) method <ce:cross-ref refid="br0100" id="crf0730">[10]</ce:cross-ref>.</ce:para><ce:para id="pr0420">According to the discussion of the backward-forward symmetric truncation in Sec. <ce:cross-ref refid="se0030" id="crf0740">3</ce:cross-ref>, it is clear that HOOI is itself not applicable in a tensor network approach to statistical physics, because the backward and forward modes should be truncated with the same semi-orthogonal frame for each direction, while HOOI very generically generates different frames for all modes. Below we present the iterative SuperQ (ISQ) method, which is inspired by the original HOOI procedure but imposes the requirement that the same frame has to be used to truncate the backward and forward modes of each direction.</ce:para><ce:para id="pr0430">As in Sec. <ce:cross-ref refid="se0040" id="crf0750">4</ce:cross-ref>, we consider a tensor <ce:italic>M</ce:italic> with <ce:italic>d</ce:italic> pairs of backward and forward modes, i.e., the tensor is of order 2<ce:italic>d</ce:italic> with dimensions <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si119.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math>, which will be truncated to dimensions <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si90.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mo>⋯</mml:mo><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math>, see <ce:cross-ref refid="fm0220" id="crf0760">(22)</ce:cross-ref>. Our aim is to minimize the squared Frobenius norm <ce:cross-ref refid="fm0140" id="crf0770">(14)</ce:cross-ref><ce:display><ce:formula id="fm0290"><ce:label>(29)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si120.svg"><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">ˆ</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> over all semi-orthogonal <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si91.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math> frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si121.svg"><mml:mi>ν</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>d</mml:mi></mml:math>, for fixed <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si98.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math>, with the additional condition that the backward and forward modes for each direction <ce:italic>ν</ce:italic> are truncated with the same frame <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>.</ce:para><ce:para id="pr0440">The semi-orthogonality of the frames is imposed explicitly by orthonormality conditions for the column vectors of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>,<ce:display><ce:formula id="fm0300"><ce:label>(30)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si122.svg"><mml:mrow><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mspace width="2em"/><mml:mtext>for </mml:mtext><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mtext> and </mml:mtext><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>ν</mml:mi><mml:mo>≤</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> in the constrained minimization of <ce:cross-ref refid="fm0290" id="crf0780">(29)</ce:cross-ref>. This leads to the cost function<ce:display><ce:formula id="fm0310"><ce:label>(31)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si123.svg"><mml:mi>g</mml:mi><mml:mo id="mmlbr0001" linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mi>C</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>d</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo>⊙</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mi>M</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mspace linebreak="newline"/><mml:mspace width="1em"/><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>ν</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:munderover><mml:mi mathvariant="normal">Tr</mml:mi><mml:mspace width="0.2em"/><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn mathvariant="double-struck">1</mml:mn><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math></ce:formula></ce:display> with matrices <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si124.svg"><mml:msup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> containing the Lagrange multipliers. The orthonormalization conditions are symmetric under the exchange <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si125.svg"><mml:mi>a</mml:mi><mml:mo stretchy="false">↔</mml:mo><mml:mi>b</mml:mi></mml:math>, and so <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si124.svg"><mml:msup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> will be symmetric too. If we diagonalize <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si126.svg"><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mtext>diag</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, redefine <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si127.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">→</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si128.svg"><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mtext>diag</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, and use the orthogonality of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si129.svg"><mml:msup><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, then Eq. <ce:cross-ref refid="fm0310" id="crf0790">(31)</ce:cross-ref> remains unaltered albeit now with diagonal <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si130.svg"><mml:msup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mtext>diag</mml:mtext><mml:mo stretchy="true" maxsize="2.4ex" minsize="2.4ex">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="true" maxsize="2.4ex" minsize="2.4ex">)</mml:mo></mml:math>, and this without loss of generality. Written out in components this is<ce:display><ce:formula id="fm0320"><ce:label>(32)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si131.svg"><mml:mi>g</mml:mi><mml:mo id="mmlbr0002" linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>ν</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:munderover><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msubsup><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo linebreak="newline" indentalign="id" indenttarget="mmlbr0002" linebreakstyle="before">=</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:msup><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">[</mml:mo><mml:munderover><mml:mo movablelimits="false">∏</mml:mo><mml:mrow><mml:mi>μ</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:munderover><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">]</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>ν</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:munderover><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msubsup><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math></ce:formula></ce:display> For a constrained maximum of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si132.svg"><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>, the partial derivative of <ce:italic>g</ce:italic> with respect to the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si133.svg"><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math>-entry of the <ce:italic>ν</ce:italic>-th orthogonal frame has to satisfy<ce:display><ce:formula id="fm0330"><ce:label>(33)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si134.svg"><mml:mrow><mml:mn>0</mml:mn><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">[</mml:mo><mml:munderover><mml:mo movablelimits="false">∏</mml:mo><mml:mrow><mml:mi>μ</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:munderover><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">]</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> for <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si135.svg"><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si136.svg"><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si137.svg"><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>ν</mml:mi><mml:mo>≤</mml:mo><mml:mi>d</mml:mi></mml:math>. Note that the same frame <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> appears twice in <ce:italic>S</ce:italic>, as it is used to truncate the modes in the backward and forward <ce:italic>ν</ce:italic> direction. We therefore obtain<ce:display><ce:formula id="fm0340"><ce:label>(34)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si138.svg"><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" id="mmlbr0003">(</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">[</mml:mo><mml:munder><mml:mo movablelimits="false">∏</mml:mo><mml:mrow><mml:mi>μ</mml:mi><mml:mo>≠</mml:mo><mml:mi>ν</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">]</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo linebreak="newline" indentalign="id" indenttarget="mmlbr0003" linebreakstyle="before">+</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">[</mml:mo><mml:munder><mml:mo movablelimits="false">∏</mml:mo><mml:mrow><mml:mi>μ</mml:mi><mml:mo>≠</mml:mo><mml:mi>ν</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">]</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>.</mml:mo></mml:math></ce:formula></ce:display> After eliminating the Kronecker deltas we get<ce:display><ce:formula id="fm0350"><ce:label>(35)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si139.svg"><mml:munder id="mmlbr0004"><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">[</mml:mo><mml:munder><mml:mo movablelimits="false">∏</mml:mo><mml:mrow><mml:mi>μ</mml:mi><mml:mo>≠</mml:mo><mml:mi>ν</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">]</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:mi>k</mml:mi><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo linebreak="newline" indentalign="id" indenttarget="mmlbr0004" linebreakstyle="before">+</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mi>c</mml:mi><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">[</mml:mo><mml:munder><mml:mo movablelimits="false">∏</mml:mo><mml:mrow><mml:mi>μ</mml:mi><mml:mo>≠</mml:mo><mml:mi>ν</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">]</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mi>k</mml:mi><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>.</mml:mo></mml:math></ce:formula></ce:display> Let us define the unfolding matrices <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si140.svg"><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si141.svg"><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> with dimensions <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si142.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>⋯</mml:mo><mml:msubsup><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>⋯</mml:mo><mml:msubsup><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:math>, where all directions of <ce:italic>M</ce:italic> are truncated, except for the backward-<ce:italic>ν</ce:italic> mode for <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si140.svg"><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, and the forward-<ce:italic>ν</ce:italic> mode for <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si141.svg"><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, and the unfolding is performed with respect to the untruncated mode,<ce:display><ce:formula id="fm0360"><ce:label>(36)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si143.svg"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.2em"/><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">[</mml:mo><mml:munder><mml:mo movablelimits="false">∏</mml:mo><mml:mrow><mml:mi>μ</mml:mi><mml:mo>≠</mml:mo><mml:mi>ν</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">]</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></ce:formula></ce:display><ce:display><ce:formula id="fm0370"><ce:label>(37)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si144.svg"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.2em"/><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">[</mml:mo><mml:munder><mml:mo movablelimits="false">∏</mml:mo><mml:mrow><mml:mi>μ</mml:mi><mml:mo>≠</mml:mo><mml:mi>ν</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="true" maxsize="5.2ex" minsize="5.2ex">]</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mspace width="0.2em"/><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> where we used the notation introduced in <ce:cross-ref refid="fm0150" id="crf0800">(15)</ce:cross-ref> for the matrix indices. The core tensor can also be written in terms of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si140.svg"><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si141.svg"><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> by truncating the remaining untruncated index:<ce:display><ce:formula id="fm0380"><ce:label>(38)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si145.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.2em"/><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.2em"/><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>.</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> After substituting <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si140.svg"><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si141.svg"><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> in <ce:cross-ref refid="fm0350" id="crf0810">(35)</ce:cross-ref> we obtain<ce:display><ce:formula id="fm0390"><ce:label>(39)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si146.svg"><mml:munder id="mmlbr0005"><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mspace width="0.2em"/><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.2em"/><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mspace width="0.2em"/><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.2em"/><mml:mo>,</mml:mo><mml:mspace width="0.2em"/><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mspace linebreak="newline"/><mml:mspace width="1em"/><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:math></ce:formula></ce:display> or<ce:display><ce:formula id="fm0400"><ce:label>(40)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si147.svg"><mml:mrow><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:munder><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>.</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> If we introduce the positive semi-definite matrices<ce:display><ce:formula id="fm0410"><ce:label>(41)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si148.svg"><mml:mrow><mml:msup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="2em"/><mml:mspace width="2em"/><mml:mi>ν</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> we can identify <ce:cross-ref refid="fm0400" id="crf0820">(40)</ce:cross-ref> as a coupled nonlinear eigenvalue problem (which is nonlinear in the eigenvectors)<ce:display><ce:formula id="fm0420"><ce:label>(42)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si149.svg"><mml:mrow><mml:mphantom><mml:mspace width="2em"/><mml:mspace width="2em"/><mml:mi>ν</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo></mml:mphantom><mml:msup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.2em"/><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="2em"/><mml:mspace width="2em"/><mml:mi>ν</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> for the semi-orthogonal frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> of dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si91.svg"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math> and the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si98.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math>-dimensional diagonal matrices <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si124.svg"><mml:msup><mml:mrow><mml:mi mathvariant="normal">Λ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>. Note that all frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si150.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si151.svg"><mml:mi>μ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>d</mml:mi></mml:math>, appear in <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si152.svg"><mml:msup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> (as projections <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si153.svg"><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup></mml:math>). This is even true for the direction <ce:italic>ν</ce:italic> itself, as its projector is applied to the forward mode in <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si154.svg"><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup></mml:math> and to the backward mode in <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si155.svg"><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup></mml:math>. Therefore the <ce:italic>ν</ce:italic>-th equation is cubic in <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> and quartic in all other <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si150.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si156.svg"><mml:mi>μ</mml:mi><mml:mo>≠</mml:mo><mml:mi>ν</mml:mi></mml:math>. It is crucial to keep in mind that the self-consistent solutions to <ce:cross-ref refid="fm0420" id="crf0830">(42)</ce:cross-ref>, which we are looking for, are required to be semi-orthogonal matrices with <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si157.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math> columns, in order to satisfy the constraints <ce:cross-ref refid="fm0300" id="crf0840">(30)</ce:cross-ref>.</ce:para><ce:para id="pr0450">It is useful to note that if we replace the matrices <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si152.svg"><mml:msup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> in <ce:cross-ref refid="fm0420" id="crf0850">(42)</ce:cross-ref> by fixed matrices <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si158.svg"><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, the <ce:italic>d</ce:italic> matrix equations decouple and each one of them is a linear eigenvalue equation for the frame <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>. The solutions of these linearized equations are however in general no solution of the original nonlinear equations <ce:cross-ref refid="fm0420" id="crf0860">(42)</ce:cross-ref>. On the other hand, if <ce:cross-ref refid="fm0420" id="crf0870">(42)</ce:cross-ref> is satisfied, then <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> is a solution of the linear eigenvalue problem for the specific matrix <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si159.svg"><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math>.</ce:para><ce:para id="pr0460">Therefore, we propose to solve the coupled system of equations using an iterative procedure, where at each iteration step, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si158.svg"><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> is computed with <ce:cross-ref refid="fm0410" id="crf0880">(41)</ce:cross-ref> using the current frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si150.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si160.svg"><mml:mi>μ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:math>, and the eigenvalue problem<ce:display><ce:formula id="fm0430"><ce:label>(43)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si161.svg"><mml:mrow><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.2em"/><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> is solved for the eigenvalues <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si162.svg"><mml:msup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> and eigenvectors <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si163.svg"><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> of the positive semi-definite matrix <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si158.svg"><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>. We then take the normalized eigenvectors corresponding to the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si98.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math> largest eigenvalues to form a new frame <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>. Note that the eigenvectors of the symmetric matrix <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si158.svg"><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> are orthogonal and therefore the constraint <ce:cross-ref refid="fm0300" id="crf0890">(30)</ce:cross-ref> is automatically satisfied for <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>.</ce:para><ce:para id="pr0470">This strategy can be motivated in the following way. We are looking for the solution of <ce:cross-ref refid="fm0420" id="crf0900">(42)</ce:cross-ref> which maximizes <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si132.svg"><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math>. Using the expression <ce:cross-ref refid="fm0380" id="crf0910">(38)</ce:cross-ref> for the core tensor <ce:italic>S</ce:italic> in terms of the unfoldings <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si140.svg"><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si141.svg"><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, the squared norm in the cost function <ce:cross-ref refid="fm0310" id="crf0920">(31)</ce:cross-ref> can be written as<ce:display><ce:formula id="fm0440"><ce:label>(44)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si164.svg"><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mi mathvariant="normal">Tr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mi mathvariant="normal">Tr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mi mathvariant="normal">Tr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> which explicitly contains the matrix <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si165.svg"><mml:msup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>≡</mml:mo><mml:msup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math> defined in <ce:cross-ref refid="fm0410" id="crf0930">(41)</ce:cross-ref> (note that this equation yields the same <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si132.svg"><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math> for each <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si166.svg"><mml:mi>ν</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:math>). It is straightforward to show that, at each iteration step, the solution obtained from the linearization <ce:cross-ref refid="fm0430" id="crf0940">(43)</ce:cross-ref> corresponds to the constrained optimization of the approximation<ce:display><ce:formula id="fm0450"><ce:label>(45)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si167.svg"><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>≈</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mi mathvariant="normal">Tr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> to <ce:cross-ref refid="fm0440" id="crf0950">(44)</ce:cross-ref>, where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si158.svg"><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> is fixed and computed with the most recent frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si150.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si160.svg"><mml:mi>μ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:math>. As this approximation is quadratic in the new frame <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, its maximum will be given by the eigenvectors corresponding to the <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si98.svg"><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math> largest eigenvalues of the symmetric, positive semi-definite matrix <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si158.svg"><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>.</ce:para><ce:para id="pr0480">The iterative procedure can be interpreted as an iterative SuperQ method, where at each step all modes of <ce:italic>M</ce:italic> are truncated using the last known frames, except for a backward mode in <ce:italic>B</ce:italic> and the corresponding forward mode in <ce:italic>F</ce:italic>.</ce:para><ce:para id="pr0490">During the iterative procedure we cycle through the <ce:italic>d</ce:italic> dimensions <ce:italic>ν</ce:italic> and determine a new frame <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> at each step using <ce:cross-ref refid="fm0430" id="crf0960">(43)</ce:cross-ref>. Then, we repeat these <ce:italic>d</ce:italic> iteration steps until all frames have converged. In practice we observed that the first iteration for each direction is the most important one, and further iterations of the same direction only give small corrections.</ce:para><ce:para id="pr0500">An alternative procedure would be to iterate <ce:cross-ref refid="fm0430" id="crf0970">(43)</ce:cross-ref> for a single <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> (keeping all other <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si150.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> fixed) until convergence has been reached (reevaluating <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si158.svg"><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> with the most recent <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> at every step), and then go on to the next frame. Once all frames have been iterated, this whole procedure is repeated until all frames converge together. Note that the inner iterations are computationally cheap, as all frames but one are kept fixed and all matrix-tensor multiplications in <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si168.svg"><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:math> and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si132.svg"><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math> involving these fixed frames have to be computed only once. However, this procedure does not seem to give an overall faster convergence.</ce:para><ce:para id="pr0510">A natural choice for the starting frames <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math>, <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si121.svg"><mml:mi>ν</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>d</mml:mi></mml:math>, in the iterative procedure are the frames obtained from the interlaced SuperQ method, see Sec. <ce:cross-ref refid="se0040" id="crf0980">4</ce:cross-ref>.</ce:para><ce:para id="pr0520">Note that the iterative procedure is not guaranteed to converge, and even when it does, the solution is not necessarily the global maximum. This can be improved upon by tuning the starting frames or by applying an under-relaxation procedure to the intermediate <ce:italic>Q</ce:italic> matrix. In this procedure, we replace <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si158.svg"><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> in <ce:cross-ref refid="fm0430" id="crf0990">(43)</ce:cross-ref> by<ce:display><ce:formula id="fm0460"><ce:label>(46)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si169.svg"><mml:mrow><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mo>‾</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mi>ω</mml:mi><mml:mspace width="0.2em"/><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.2em"/><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mtext>prev</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mspace width="0.2em"/><mml:mo>,</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> where <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si170.svg"><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>ˆ</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mtext>prev</mml:mtext></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:math> was used to obtain the previous <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si84.svg"><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math> in the iterative procedure. The relaxation procedure can be used to optimize <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si132.svg"><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math> by tuning the local parameter <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si171.svg"><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>ω</mml:mi><mml:mo>≤</mml:mo><mml:mn>1</mml:mn></mml:math>. We observed that a coarse tuning of <ce:italic>ω</ce:italic> is sufficient to improve the overall convergence of the iterative procedure.</ce:para><ce:para id="pr0530">When applying the ISQ method to HOTRG, where <ce:italic>M</ce:italic> is a contraction <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si116.svg"><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>⋆</mml:mo></mml:mrow><mml:mrow><mml:mi>ν</mml:mi></mml:mrow></mml:msub><mml:mi>T</mml:mi></mml:math> along one of the directions, only <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si117.svg"><mml:mn>2</mml:mn><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:math> of 2<ce:italic>d</ce:italic> modes will actually be truncated, as the backward and forward modes for the contracted direction are left unchanged. For the two-dimensional case, where only one frame has to be determined after each contraction, an alternative method to optimize the truncation using a linearization was proposed in the <ce:italic>projective truncation</ce:italic> of Ref. <ce:cross-ref refid="br0110" id="crf1000">[11]</ce:cross-ref>.</ce:para></ce:section><ce:section id="se0060"><ce:label>6</ce:label><ce:section-title id="st0070">Examples</ce:section-title><ce:para id="pr0540">In the following, we illustrate the effect of the SuperQ and ISQ methods. For various random tensors <ce:italic>A</ce:italic>, we compute core tensors <ce:italic>S</ce:italic> using the standard HOSVD approximation <ce:cross-ref refid="br0070" id="crf1010">[7]</ce:cross-ref> and the best possible approximation of a given multi-rank with the HOOI method <ce:cross-ref refid="br0100" id="crf1020">[10]</ce:cross-ref>. These results are compared with the following backward-forward symmetric approximations: the method proposed by Xie et al. (used in standard HOTRG <ce:cross-ref refid="br0060" id="crf1030">[6]</ce:cross-ref>), the SuperQ approximation of Sec. <ce:cross-ref refid="se0040" id="crf1040">4</ce:cross-ref>, and the ISQ approximation of Sec. <ce:cross-ref refid="se0050" id="crf1050">5</ce:cross-ref>. The relative error for each of these approximations is given by<ce:display><ce:formula id="fm0470"><ce:label>(47)</ce:label><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si172.svg"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:msqrt><mml:mo>.</mml:mo></mml:mrow></mml:math></ce:formula></ce:display> The comparison of the different methods will be illustrated by plotting <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si173.svg"><mml:mo stretchy="false">(</mml:mo><mml:mi>ϵ</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:msub><mml:mrow><mml:mi>ϵ</mml:mi></mml:mrow><mml:mrow><mml:mtext>hooi</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mrow><mml:mi>ϵ</mml:mi></mml:mrow><mml:mrow><mml:mtext>hooi</mml:mtext></mml:mrow></mml:msub></mml:math> in the figures below. For the ISQ method the iterations are initialized with the frames obtained using the interlaced SuperQ method. The ISQ method is iterated until the relative error <ce:italic>ϵ</ce:italic> has a relative change of less than <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si174.svg"><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:msup></mml:math> between two major iterations, where a major iteration corresponds to one update of all frames. For each iteration we tune the relaxation parameter <ce:italic>ω</ce:italic> to reduce the error. The number of major iterations varies between 20 and 100 with an average of around 50.</ce:para><ce:para id="pr0550">In a first example we consider random tensors <ce:italic>A</ce:italic> of order 4 with dimension <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si175.svg"><mml:mn>10</mml:mn><mml:mo>×</mml:mo><mml:mn>10</mml:mn><mml:mo>×</mml:mo><mml:mn>100</mml:mn><mml:mo>×</mml:mo><mml:mn>100</mml:mn></mml:math>, whose rank is reduced by truncating the last two indices to dimension 10. The results shown in <ce:cross-ref refid="fg0060" id="crf1060">Fig. 6</ce:cross-ref><ce:float-anchor refid="fg0060"/> were computed for initial tensors filled with uniformly distributed elements in <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si176.svg"><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math> (left panel) and normally distributed elements with mean <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si177.svg"><mml:mi>μ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>0</mml:mn></mml:math> and standard deviation <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si178.svg"><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:math> (right panel). In another example, shown in <ce:cross-ref refid="fg0070" id="crf1070">Fig. 7</ce:cross-ref><ce:float-anchor refid="fg0070"/>, all modes of random <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" altimg="si179.svg"><mml:mn>30</mml:mn><mml:mo>×</mml:mo><mml:mn>30</mml:mn><mml:mo>×</mml:mo><mml:mn>30</mml:mn><mml:mo>×</mml:mo><mml:mn>30</mml:mn></mml:math> tensors are reduced to dimension 10. Again the random tensors are filled with elements from a uniform distribution (left) and a normal distribution (right).</ce:para><ce:para id="pr0560">In all examples, the hierarchy between the approximations is the same. In decreasing order of accuracy we find: HOOI, ISQ, HOSVD, SuperQ, and finally the Xie-method. We notice that, as we suggested in the derivation of Sec. <ce:cross-ref refid="se0040" id="crf1080">4</ce:cross-ref>, the SuperQ method performs better than the Xie-method. Both of them are superseded by HOSVD, which is logical as the latter does not have to satisfy the additional backward-forward symmetry constraint. However, a somewhat unexpected result is that in all examples, the ISQ method performs better than the standard HOSVD approximation, even though the former does satisfy the additional backward-forward symmetry constraint. In all cases HOOI performs best, as it is the best possible approximation of the given multi-rank.</ce:para></ce:section><ce:section id="se0070" role="conclusion"><ce:label>7</ce:label><ce:section-title id="st0080">Conclusions</ce:section-title><ce:para id="pr0570">In this paper we consider the reduction of the local truncation error in a single blocking step of the HOTRG procedure. We have discussed in detail the constraints imposed on the semi-orthogonal truncation frames in the HOTRG algorithm, where the backward and forward modes for each direction have to be projected on the same lower-dimensional subspace at each blocking step. We first introduced the SuperQ method, which minimizes a combined error on the backward and forward unfoldings for each individual direction. The method is computationally more efficient and generically yields a reduced local truncation error when compared to the original HOTRG truncation.</ce:para><ce:para id="pr0580">As a further improvement, we presented the iterative SuperQ method, where we formulate a constrained minimization problem, which leads to equations that have to be satisfied by the semi-orthogonal truncation frames in order to minimize the error on the lower-rank tensor approximation, while satisfying the backward-forward symmetry constraints. The method is inspired by the HOOI method, with the additional requirement that the same frames are used on the backward and forward modes of each direction. The equations form a coupled nonlinear eigenvalue problem, which we propose to solve using an iterative procedure, where decoupled linear eigenvalue problems are solved at each iteration step. Computing the optimal backward-forward symmetric truncation frames with the ISQ method is more expensive than the truncation applied in the original HOTRG method, as each iteration step requires new eigenvalue decompositions. Therefore, in practice, we generally use the SuperQ truncation in the HOTRG blocking procedure, since it provides the best trade-off between computational cost and truncation accuracy.</ce:para> </ce:section></ce:sections><ce:conflict-of-interest id="coi0001"><ce:section-title id="st0110">Declaration of Competing Interest</ce:section-title><ce:para id="pr0600">The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.</ce:para></ce:conflict-of-interest></body><tail><ce:bibliography id="bl0010"><ce:section-title id="st0090">References</ce:section-title><ce:bibliography-sec id="bs0010"><ce:bib-reference id="br0010"><ce:label>[1]</ce:label><sb:reference id="bibA8ADBA9948CF4049789F19CD935C1B6As1"><sb:contribution><sb:authors><sb:author><ce:given-name>G.</ce:given-name><ce:surname>Aarts</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Recent developments at finite density on the lattice</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>PoS CPOD2014</sb:maintitle></sb:title></sb:series><sb:date>2014</sb:date></sb:issue><sb:article-number>012</sb:article-number><ce:doi>10.22323/1.217.0012</ce:doi></sb:host><sb:host><sb:e-host><ce:inter-ref xlink:role="http://www.elsevier.com/xml/linking-roles/preprint" xlink:href="arxiv:1502.01850" id="inf0010">arXiv:1502.01850</ce:inter-ref></sb:e-host></sb:host></sb:reference><ce:source-text id="srct0015">G. Aarts, Recent developments at finite density on the lattice, PoS CPOD2014 (2014) 012. arXiv:1502.01850, doi:10.22323/1.217.0012.</ce:source-text></ce:bib-reference><ce:bib-reference id="br0020"><ce:label>[2]</ce:label><sb:reference id="bib7EFCA98ACF45E0BD3CD708C737883071s1"><sb:contribution><sb:authors><sb:author><ce:given-name>G.</ce:given-name><ce:surname>Aarts</ce:surname></sb:author><sb:author><ce:given-name>F.</ce:given-name><ce:surname>Attanasio</ce:surname></sb:author><sb:author><ce:given-name>B.</ce:given-name><ce:surname>Jäger</ce:surname></sb:author><sb:author><ce:given-name>E.</ce:given-name><ce:surname>Seiler</ce:surname></sb:author><sb:author><ce:given-name>D.</ce:given-name><ce:surname>Sexty</ce:surname></sb:author><sb:author><ce:given-name>I.-O.</ce:given-name><ce:surname>Stamatescu</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>QCD at nonzero chemical potential: recent progress on the lattice</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>AIP Conf. Proc.</sb:maintitle></sb:title><sb:volume-nr>1701</sb:volume-nr></sb:series><sb:date>2016</sb:date></sb:issue><sb:article-number>020001</sb:article-number><ce:doi>10.1063/1.4938590</ce:doi></sb:host><sb:host><sb:e-host><ce:inter-ref xlink:role="http://www.elsevier.com/xml/linking-roles/preprint" xlink:href="arxiv:1412.0847" id="inf0020">arXiv:1412.0847</ce:inter-ref></sb:e-host></sb:host></sb:reference><ce:source-text id="srct0020">G. Aarts, F. Attanasio, B. Jäger, E. Seiler, D. Sexty, I.-O. Stamatescu, QCD at nonzero chemical potential: recent progress on the lattice, AIP Conf. Proc. 1701 (2016) 020001. arXiv:1412.0847, doi:10.1063/1.4938590.</ce:source-text></ce:bib-reference><ce:bib-reference id="br0030"><ce:label>[3]</ce:label><sb:reference id="bib0C5EFDA743CEBC1D24E82B3FB73A0E04s1"><sb:contribution><sb:authors><sb:author><ce:given-name>C.</ce:given-name><ce:surname>Gattringer</ce:surname></sb:author><sb:author><ce:given-name>K.</ce:given-name><ce:surname>Langfeld</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Approaches to the sign problem in lattice field theory</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Int. J. Mod. Phys. A</sb:maintitle></sb:title><sb:volume-nr>31</sb:volume-nr></sb:series><sb:issue-nr>22</sb:issue-nr><sb:date>2016</sb:date></sb:issue><sb:article-number>1643007</sb:article-number><ce:doi>10.1142/S0217751X16430077</ce:doi></sb:host><sb:host><sb:e-host><ce:inter-ref xlink:role="http://www.elsevier.com/xml/linking-roles/preprint" xlink:href="arxiv:1603.09517" id="inf0030">arXiv:1603.09517</ce:inter-ref></sb:e-host></sb:host></sb:reference><ce:source-text id="srct0025">C. Gattringer, K. Langfeld, Approaches to the sign problem in lattice field theory, International Journal of Modern Physics A 31 (22) (2016) 1643007. arXiv:1603.09517, doi:10.1142/S0217751X16430077.</ce:source-text></ce:bib-reference><ce:bib-reference id="br0040"><ce:label>[4]</ce:label><sb:reference id="bib696B2F842C47DAD4ADE09F94B7EB7E02s1"><sb:contribution><sb:authors><sb:author><ce:given-name>Y.</ce:given-name><ce:surname>Meurice</ce:surname></sb:author><sb:author><ce:given-name>R.</ce:given-name><ce:surname>Sakai</ce:surname></sb:author><sb:author><ce:given-name>J.</ce:given-name><ce:surname>Unmuth-Yockey</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Tensor lattice field theory for renormalization and quantum computing</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Rev. Mod. Phys.</sb:maintitle></sb:title><sb:volume-nr>94</sb:volume-nr></sb:series><sb:issue-nr>2</sb:issue-nr><sb:date>2022</sb:date></sb:issue><sb:article-number>025005</sb:article-number><ce:doi>10.1103/RevModPhys.94.025005</ce:doi></sb:host><sb:host><sb:e-host><ce:inter-ref xlink:role="http://www.elsevier.com/xml/linking-roles/preprint" xlink:href="arxiv:2010.06539" id="inf0040">arXiv:2010.06539</ce:inter-ref></sb:e-host></sb:host></sb:reference><ce:source-text id="srct0030">Y. Meurice, R. Sakai, J. Unmuth-Yockey, Tensor lattice field theory for renormalization and quantum computing, Rev. Mod. Phys. 94 (2) (2022) 025005. arXiv:2010.06539, doi:10.1103/RevModPhys.94.025005.</ce:source-text></ce:bib-reference><ce:bib-reference id="br0050"><ce:label>[5]</ce:label><sb:reference id="bib2E65F907E1082C4D5A3CAFE981BB4AD6s1"><sb:contribution><sb:authors><sb:author><ce:given-name>M.</ce:given-name><ce:surname>Levin</ce:surname></sb:author><sb:author><ce:given-name>C.P.</ce:given-name><ce:surname>Nave</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Tensor renormalization group approach to two-dimensional classical lattice models</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Phys. Rev. Lett.</sb:maintitle></sb:title><sb:volume-nr>99</sb:volume-nr></sb:series><sb:issue-nr>12</sb:issue-nr><sb:date>2007</sb:date></sb:issue><sb:article-number>120601</sb:article-number><ce:doi>10.1103/PhysRevLett.99.120601</ce:doi></sb:host><sb:host><sb:e-host><ce:inter-ref xlink:role="http://www.elsevier.com/xml/linking-roles/preprint" xlink:href="arxiv:cond-mat/0611687" id="inf0050">arXiv:cond-mat/0611687</ce:inter-ref></sb:e-host></sb:host></sb:reference><ce:source-text id="srct0035">M. Levin, C. P. Nave, Tensor renormalization group approach to two-dimensional classical lattice models, Phys. Rev. Lett. 99 (12) (2007) 120601. arXiv:cond-mat/0611687, doi:10.1103/PhysRevLett.99.120601.</ce:source-text></ce:bib-reference><ce:bib-reference id="br0060"><ce:label>[6]</ce:label><sb:reference id="bib056A7CC6592F2F0265E3A84AE6EACE92s1"><sb:contribution><sb:authors><sb:author><ce:given-name>Z.Y.</ce:given-name><ce:surname>Xie</ce:surname></sb:author><sb:author><ce:given-name>J.</ce:given-name><ce:surname>Chen</ce:surname></sb:author><sb:author><ce:given-name>M.P.</ce:given-name><ce:surname>Qin</ce:surname></sb:author><sb:author><ce:given-name>J.W.</ce:given-name><ce:surname>Zhu</ce:surname></sb:author><sb:author><ce:given-name>L.P.</ce:given-name><ce:surname>Yang</ce:surname></sb:author><sb:author><ce:given-name>T.</ce:given-name><ce:surname>Xiang</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Coarse-graining renormalization by higher-order singular value decomposition</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Phys. Rev. B</sb:maintitle></sb:title><sb:volume-nr>86</sb:volume-nr></sb:series><sb:issue-nr>4</sb:issue-nr><sb:date>2012</sb:date></sb:issue><sb:article-number>045139</sb:article-number><ce:doi>10.1103/physrevb.86.045139</ce:doi></sb:host></sb:reference><ce:source-text id="srct0040">Z. Y. Xie, J. Chen, M. P. Qin, J. W. Zhu, L. P. Yang, T. Xiang, Coarse-graining renormalization by higher-order singular value decomposition, Phys. Rev. B86 (4) (2012) 045139. doi:10.1103/physrevb.86.045139.</ce:source-text></ce:bib-reference><ce:bib-reference id="br0070"><ce:label>[7]</ce:label><sb:reference id="bib643480BF1614D860C48C1293B4364CA5s1"><sb:contribution><sb:authors><sb:author><ce:given-name>L.</ce:given-name><ce:surname>De Lathauwer</ce:surname></sb:author><sb:author><ce:given-name>B.</ce:given-name><ce:surname>De Moor</ce:surname></sb:author><sb:author><ce:given-name>J.</ce:given-name><ce:surname>Vandewalle</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>A multilinear singular value decomposition</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>SIAM J. Matrix Anal. Appl.</sb:maintitle></sb:title><sb:volume-nr>21</sb:volume-nr></sb:series><sb:issue-nr>4</sb:issue-nr><sb:date>2000</sb:date></sb:issue><sb:pages><sb:first-page>1253</sb:first-page><sb:last-page>1278</sb:last-page></sb:pages><ce:doi>10.1137/S0895479896305696</ce:doi></sb:host></sb:reference><ce:source-text id="srct0045">L. De Lathauwer, B. De Moor, J. Vandewalle, A multilinear singular value decomposition, SIAM Journal on Matrix Analysis and Applications 21 (4) (2000) 1253–1278. doi:10.1137/S0895479896305696.</ce:source-text></ce:bib-reference><ce:bib-reference id="br0080"><ce:label>[8]</ce:label><sb:reference id="bibDD0632E0D8DFC438B5CEED5225868689s1"><sb:contribution><sb:authors><sb:author><ce:given-name>Y.</ce:given-name><ce:surname>Liu</ce:surname></sb:author><sb:author><ce:given-name>Y.</ce:given-name><ce:surname>Meurice</ce:surname></sb:author><sb:author><ce:given-name>M.P.</ce:given-name><ce:surname>Qin</ce:surname></sb:author><sb:author><ce:given-name>J.</ce:given-name><ce:surname>Unmuth-Yockey</ce:surname></sb:author><sb:author><ce:given-name>T.</ce:given-name><ce:surname>Xiang</ce:surname></sb:author><sb:author><ce:given-name>Z.Y.</ce:given-name><ce:surname>Xie</ce:surname></sb:author><sb:author><ce:given-name>J.F.</ce:given-name><ce:surname>Yu</ce:surname></sb:author><sb:author><ce:given-name>H.</ce:given-name><ce:surname>Zou</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Exact blocking formulas for spin and gauge models</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Phys. Rev. D</sb:maintitle></sb:title><sb:volume-nr>88</sb:volume-nr></sb:series><sb:date>2013</sb:date></sb:issue><sb:article-number>056005</sb:article-number><ce:doi>10.1103/PhysRevD.88.056005</ce:doi></sb:host><sb:host><sb:e-host><ce:inter-ref xlink:role="http://www.elsevier.com/xml/linking-roles/preprint" xlink:href="arxiv:1307.6543" id="inf0060">arXiv:1307.6543</ce:inter-ref></sb:e-host></sb:host></sb:reference><ce:source-text id="srct0050">Y. Liu, Y. Meurice, M. P. Qin, J. Unmuth-Yockey, T. Xiang, Z. Y. Xie, J. F. Yu, H. Zou, Exact blocking formulas for spin and gauge models, Phys. Rev. D88 (2013) 056005. arXiv:1307.6543, doi:10.1103/PhysRevD.88.056005.</ce:source-text></ce:bib-reference><ce:bib-reference id="br0090"><ce:label>[9]</ce:label><sb:reference id="bib57BF939360597AFB41015318A056BD62s1"><sb:contribution><sb:authors><sb:author><ce:given-name>H.-H.</ce:given-name><ce:surname>Zhao</ce:surname></sb:author><sb:author><ce:given-name>Z.-Y.</ce:given-name><ce:surname>Xie</ce:surname></sb:author><sb:author><ce:given-name>T.</ce:given-name><ce:surname>Xiang</ce:surname></sb:author><sb:author><ce:given-name>M.</ce:given-name><ce:surname>Imada</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Tensor network algorithm by coarse-graining tensor renormalization on finite periodic lattices</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Phys. Rev. B</sb:maintitle></sb:title><sb:volume-nr>93</sb:volume-nr></sb:series><sb:issue-nr>12</sb:issue-nr><sb:date>2016</sb:date></sb:issue><ce:doi>10.1103/physrevb.93.125115</ce:doi></sb:host></sb:reference><ce:source-text id="srct0055">H.-H. Zhao, Z.-Y. Xie, T. Xiang, M. Imada, Tensor network algorithm by coarse-graining tensor renormalization on finite periodic lattices, Physical Review B 93 (12) . doi:10.1103/physrevb.93.125115.</ce:source-text></ce:bib-reference><ce:bib-reference id="br0100"><ce:label>[10]</ce:label><sb:reference id="bibEF9F298DCBE63FF2D577DD98C8F7AD7Es1"><sb:contribution><sb:authors><sb:author><ce:given-name>L.</ce:given-name><ce:surname>De Lathauwer</ce:surname></sb:author><sb:author><ce:given-name>B.</ce:given-name><ce:surname>De Moor</ce:surname></sb:author><sb:author><ce:given-name>J.</ce:given-name><ce:surname>Vandewalle</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>On the best rank-1 and rank-(R1,R2,...,RN) approximation of higher-order tensors</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>SIAM J. Matrix Anal. Appl.</sb:maintitle></sb:title><sb:volume-nr>21</sb:volume-nr></sb:series><sb:issue-nr>4</sb:issue-nr><sb:date>2000</sb:date></sb:issue><sb:pages><sb:first-page>1324</sb:first-page><sb:last-page>1342</sb:last-page></sb:pages><ce:doi>10.1137/S0895479898346995</ce:doi></sb:host></sb:reference><ce:source-text id="srct0060">L. De Lathauwer, B. De Moor, J. Vandewalle, On the best rank-1 and rank-(R1,R2,...,RN) approximation of higher-order tensors, SIAM Journal on Matrix Analysis and Applications 21 (4) (2000) 1324–1342. doi:10.1137/S0895479898346995.</ce:source-text></ce:bib-reference><ce:bib-reference id="br0110"><ce:label>[11]</ce:label><sb:reference id="bib89CCA002DD0C4A55F531CF4B5D1E470As1"><sb:contribution><sb:authors><sb:author><ce:given-name>G.</ce:given-name><ce:surname>Evenbly</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Algorithms for tensor network renormalization</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Phys. Rev. B</sb:maintitle></sb:title><sb:volume-nr>95</sb:volume-nr></sb:series><sb:date>2017</sb:date></sb:issue><sb:article-number>045117</sb:article-number><ce:doi>10.1103/PhysRevB.95.045117</ce:doi></sb:host><sb:host><sb:e-host><ce:inter-ref xlink:role="http://www.elsevier.com/xml/linking-roles/preprint" xlink:href="arxiv:1509.07484" id="inf0070">arXiv:1509.07484</ce:inter-ref></sb:e-host></sb:host></sb:reference><ce:source-text id="srct0065">G. Evenbly, Algorithms for tensor network renormalization, Phys. Rev. B95 (2017) 045117. arXiv:1509.07484, doi:10.1103/PhysRevB.95.045117.</ce:source-text></ce:bib-reference></ce:bibliography-sec></ce:bibliography></tail></article>
